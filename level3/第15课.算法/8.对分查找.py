"""

15.10 对分查花

15.10.1问题引入

从1-100随机取一个数字,以最少的次数猜中这个数字,应该怎么做呢?如果从1开始以此往上猜,
直到猜中数字,这是简单的顺序查找算法,每次猜测这是只能排除一个数字。

如果从50开始猜,告诉你猜大了或者猜小了,这样每猜一次,都会将剩余的数字排除掉一半。
不管取到哪个数字,你在7次之内都能够猜到,因为每次猜测都将排除很多数字!

相比之下,第二种方法会更加省时,这种算法叫作对分查找算法,又称二分查找算法。

15.10.2 知识点详解

1.对分查找的概念

对分查找又称二分查找,是一种高效的查找方法。
对分查找的前提是,被查找的数据序列是有序的(升序或降序)。
对分查找的基本思想是在有序的数列中,首先将要查找的数据与有序数列内处于中间位置的数据进行比较,
如果两者相等,则查找成功;否则就根据数据的有序性,再确定该数据的范围应该在数列的前半部分还是后半部分;
在新确定的缩小范围内,继续按上述方法进行查找,直到找到要查找的数据,即查找成功;

如果要查找的数据不存在,即查找不成功。

2.对分查找的处理过程

若key为查找键,列表a存放n个已按升序排序的元素。
在使用对分查找时,把查找范围[i,j]的中间位置上的数据a[m]与查找键key进行比较,
结果必然是如下3种情况之一,

(1)若key<a[m],查找键小于中点a[m]处的数据。由a中的数据的递增性可以确定:
在(m,j)内不可能存在值为key的数据,必须在新的范围(i, m-1)中继续查找。

(2)若key = a[m],找到了需要的数据。

(3)若key>a[m),必须在新的范围(m+ 1,j)中继续查找。

这样,除了出现情况(2),在通过一次比较后,新的查找范围将不超过上次查找范围的一半。
中间位置数据a[m]的下标m的计算方法是: m = (i + j) // 2 或 m = int(( i+j )/2)

3.对分查找的程序实现

(1)由于比较次数难以确定,所以用while语句来实现循环。
(2)在while循环体中用if语句来判断查找是否成功。
(3)若查找成功则输出查找结果,并用break语句结束循环。
(4)若查找不成功,则判断查找键在数组的左半区间还是右半区间,从而缩小范围,继续查找。

我们假设有一个列表 lst = [12, 17, 23, 25, 26, 35, 47, 68, 76, 88,96],
要查找元素key=25,则其对分查找的程序如下。

lst = [12, 17, 23, 25, 26, 35, 47, 68, 76, 88, 96]
key = 25
n = len (1st)
i, j = 0, n - 1
b = -1

while i <= j:
    m = (i + j) // 2
    if key == lst[m]:
        b = m #找到了要找的数,赋值给b
        break #找到key,退出循环
    elif key > lst[m]:
        i = m + 1
    else:
        j = m - 1
if b == -1: #-1代表元素未查找到
    print ("要查找的元素[" + str (key) + "]不在列表1st 中。")
else:
    print ("要查找的元素[" + str (key) + "]的索引是: " + str (b))

4.对分查找的查找次数估算

对元素规模为n的列表进行对分查找时,无论是否找到,至多进行log₂n次查找就能得到结果；
而使用顺查找算法，在最坏的情况下(查找键在最后一个或没找到),需要讲行n次查找，
最好的情况是1次查找(查找键在第一个)，平均查找次数是 n + 1 / 2(这是分数)

思考题

(1)下列有关查找的说法,正确的是

A.顺序查找时,被查找的数据必须有序
B.对分查找时,被查找的数据不一定有序
C.顺序查找总能找到要查找的关键字
D.一般情况下,对分查找的效率较高

(2)某列表有7个元素,依次为19、28、30、35、39、42、48。
若采用对分查找算法在该列表中查找元素48,需要查找的次数是( )。
A.1 B.2 C.3 D.4

15.10.3 易错点

(1)对分查找算法中查找区间的形成。
(2)对于分治思想的理解。

15.10.4 模拟考题

考题1单选题

对于n个元素,利用对分查找算法,最坏的情况是查找()次才结束。

A.n  B. n/2  C. n  D. log₂n

答案: D

考题2编程题

科技小组分2个小队搜集到西红柿生长的数据信息。2个小队将数据进行了从小到大排序:
a = 11,3,4,6,7, 13,17,21],
b = [2,5,6,8,10,12, 14,16, 18]。

请将这2个小队的数据进行合并,生成为一个从小到大有序的列表。输入:

1,3,4,6,7,13,17,21
2,5,6,8,10,12,14,16,18

输出:

(1,2,3,4,5,6,6,7,8,10,12,13,14,16,17,18,21)

请编写程序实现上述功能,或补全代码。

x = input()
s = x.split(',')
a = []

for i in range (空白):
    a.append(int(s[i]))
y = input()
s = y.空白

b = []

for i in range(len(s)):
    b.append(int(s(1]))
ret = []
i = j = 0

while len(a) >= i+ 1 and 空白
    if a【i] <= b[j]:
        空白
        i += 1
    else:
        ret.append(b[j])
        j += 1
if len (a) > i:
    ret += a[i:]
if len (b) > j:
    空白
print (ret)

评分标准:
1：len(s)或等效答案(3分)
2：split(',')或等效答案(3分)
3：len(b) >= j+1或等效答案(3分)
4：ret.append(a[i]) 或等效答案(3分)
5：ret += b[j:]或等效答案(4分)

"""